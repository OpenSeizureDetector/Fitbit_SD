"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var error_subclass_1 = tslib_1.__importDefault(require("error-subclass"));
var MAX_HEADER_LENGTH = 4096;
var PPMParseError = (function (_super) {
    tslib_1.__extends(PPMParseError, _super);
    function PPMParseError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PPMParseError.displayName = 'PPMParseError';
    return PPMParseError;
}(error_subclass_1.default));
exports.PPMParseError = PPMParseError;
function parseHeaderField(field) {
    return parseInt(field.replace(/#.*[\r\n]/g, ''), 10);
}
var PortablePixmap = (function () {
    function PortablePixmap(width, height, maxval, data) {
        this.width = width;
        this.height = height;
        this.maxval = maxval;
        this.data = data;
    }
    PortablePixmap.prototype.toRGBA8888 = function (destination) {
        var pixels = this.width * this.height;
        var buffer = destination || new Uint8ClampedArray(pixels * 4);
        if (buffer.length < pixels * 4)
            throw new Error('Destination array too small');
        if (this.maxval < 256) {
            for (var i = 0; i < pixels; i += 1) {
                buffer[i * 4] = (this.data[i * 3] * 255) / this.maxval;
                buffer[(i * 4) + 1] = (this.data[(i * 3) + 1] * 255) / this.maxval;
                buffer[(i * 4) + 2] = (this.data[(i * 3) + 2] * 255) / this.maxval;
                buffer[(i * 4) + 3] = 255;
            }
        }
        else {
            for (var i = 0; i < pixels; i += 1) {
                buffer[(i * 4)] = (this.data.readUInt16BE(i * 6) * 255) / this.maxval;
                buffer[(i * 4) + 1] = (this.data.readUInt16BE((i * 6) + 2) * 255) / this.maxval;
                buffer[(i * 4) + 2] = (this.data.readUInt16BE((i * 6) + 4) * 255) / this.maxval;
                buffer[(i * 4) + 3] = 255;
            }
        }
        return buffer;
    };
    PortablePixmap.parse = function (buffer) {
        var lexer = {
            magic: /P6(?:\s|#.*[\r\n])*\s/y,
            dimension: /(?:\s|#.*[\r\n])*(\d(?:\d|#.*[\r\n])*)\s+/y,
            maxval: /(?:\s|#.*[\r\n])*(\d(?:\d|#.*[\r\n])*)[\r\n]/y,
        };
        var header = buffer.toString('binary', 0, MAX_HEADER_LENGTH);
        if (!lexer.magic.test(header)) {
            throw new PPMParseError('bad magic');
        }
        lexer.dimension.lastIndex = lexer.magic.lastIndex;
        var widthField = lexer.dimension.exec(header);
        if (widthField === null)
            throw new PPMParseError('malformed width');
        var heightField = lexer.dimension.exec(header);
        if (heightField === null)
            throw new PPMParseError('malformed height');
        lexer.maxval.lastIndex = lexer.dimension.lastIndex;
        var maxvalField = lexer.maxval.exec(header);
        if (maxvalField === null)
            throw new PPMParseError('malformed maxval');
        var width = parseHeaderField(widthField[1]);
        var height = parseHeaderField(heightField[1]);
        var maxval = parseHeaderField(maxvalField[1]);
        if (width === 0)
            throw new PPMParseError('width is zero');
        if (height === 0)
            throw new PPMParseError('height is zero');
        if (maxval <= 0 || maxval >= 65536) {
            throw new PPMParseError("maxval out of range: " + maxval);
        }
        var rasterStart = lexer.maxval.lastIndex;
        var rasterEnd = rasterStart + (width * height * 3 * (maxval > 255 ? 2 : 1));
        if (rasterEnd > buffer.length)
            throw new PPMParseError('truncated file');
        return new this(width, height, maxval, buffer.slice(rasterStart, rasterEnd));
    };
    return PortablePixmap;
}());
exports.default = PortablePixmap;
