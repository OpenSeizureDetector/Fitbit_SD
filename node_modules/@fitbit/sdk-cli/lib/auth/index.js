"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const authorization_request_1 = require("@openid/appauth/built/authorization_request");
const authorization_request_handler_1 = require("@openid/appauth/built/authorization_request_handler");
const authorization_service_configuration_1 = require("@openid/appauth/built/authorization_service_configuration");
const appAuthFlags = tslib_1.__importStar(require("@openid/appauth/built/flags"));
const revoke_token_request_1 = require("@openid/appauth/built/revoke_token_request");
const token_request_1 = require("@openid/appauth/built/token_request");
const node_request_handler_1 = require("@openid/appauth/built/node_support/node_request_handler");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const randomstring_1 = tslib_1.__importDefault(require("randomstring"));
const environment_1 = tslib_1.__importDefault(require("./environment"));
const storage_1 = tslib_1.__importDefault(require("./storage"));
const FitbitTokenRequestHandler_1 = tslib_1.__importDefault(require("./FitbitTokenRequestHandler"));
appAuthFlags.IS_LOG = false;
const tokenHandler = new FitbitTokenRequestHandler_1.default();
function getAuthConfiguration() {
    const { apiUrl } = environment_1.default().config;
    return authorization_service_configuration_1.AuthorizationServiceConfiguration.fromJson({
        token_endpoint: `${apiUrl}/oauth2/token`,
        authorization_endpoint: `${apiUrl}/oauth2/authorize`,
        revocation_endpoint: `${apiUrl}/oauth2/revoke`,
    });
}
function base64URLEncode(buf) {
    return buf.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
async function refreshToken(refreshToken) {
    const { clientId } = environment_1.default().config;
    try {
        const response = await tokenHandler.performTokenRequest(getAuthConfiguration(), new token_request_1.TokenRequest(clientId, '', token_request_1.GRANT_TYPE_REFRESH_TOKEN, undefined, refreshToken));
        await storage_1.default.set(response);
        return response.accessToken;
    }
    catch (ex) {
        await storage_1.default.clear();
        throw ex;
    }
}
exports.refreshToken = refreshToken;
function authError(msg) {
    return new Error(`Authorization error: ${msg}`);
}
function authorizationCallbackPromise(handler) {
    const notifier = new authorization_request_handler_1.AuthorizationNotifier();
    handler.setAuthorizationNotifier(notifier);
    return new Promise((resolve, reject) => {
        notifier.setAuthorizationListener((request, response, error) => {
            if (error) {
                if (error.errorDescription) {
                    return reject(authError(`${error.error}: ${error.errorDescription}`));
                }
                return reject(authError(error.error));
            }
            resolve(response);
        });
    });
}
async function authorize() {
    const { clientId } = environment_1.default().config;
    const expectedState = randomstring_1.default.generate(32);
    const pkceVerifier = base64URLEncode(crypto_1.default.randomBytes(32));
    const pkceChallenge = base64URLEncode(crypto_1.default.createHash('sha256').update((pkceVerifier)).digest());
    const port = 13579;
    const redirectUri = `http://127.0.0.1:${port}`;
    const authorizationHandler = new node_request_handler_1.NodeBasedHandler(port);
    authorizationHandler.performAuthorizationRequest(getAuthConfiguration(), new authorization_request_1.AuthorizationRequest(clientId, redirectUri, 'profile', authorization_request_1.AuthorizationRequest.RESPONSE_TYPE_CODE, expectedState, {
        code_challenge: pkceChallenge,
        code_challenge_method: 'S256',
    }));
    const { state, code } = await authorizationCallbackPromise(authorizationHandler);
    if (state !== expectedState)
        throw authError('Mismatched state');
    return {
        code,
        pkceVerifier,
        redirectUri,
    };
}
async function revoke(token) {
    await tokenHandler.performRevokeTokenRequest(getAuthConfiguration(), new revoke_token_request_1.RevokeTokenRequest(token));
}
async function login() {
    const { clientId } = environment_1.default().config;
    const { code, pkceVerifier, redirectUri } = await authorize();
    const response = await tokenHandler.performTokenRequest(getAuthConfiguration(), new token_request_1.TokenRequest(clientId, redirectUri, token_request_1.GRANT_TYPE_AUTHORIZATION_CODE, code, undefined, { code_verifier: pkceVerifier }));
    await storage_1.default.set(response);
}
exports.login = login;
async function logout() {
    const authData = await storage_1.default.get();
    if (!authData)
        return;
    await Promise.all([
        revoke(authData.accessToken),
        storage_1.default.clear(),
    ]);
}
exports.logout = logout;
async function getAccessToken() {
    const authData = await storage_1.default.get();
    if (authData === null)
        return null;
    if (authData.isValid())
        return authData.accessToken;
    return refreshToken(authData.refreshToken);
}
exports.getAccessToken = getAccessToken;
//# sourceMappingURL=index.js.map