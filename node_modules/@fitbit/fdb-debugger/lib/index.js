"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var events_1 = require("events");
var t = require("io-ts");
var jsonrpc_ts_1 = require("@fitbit/jsonrpc-ts");
var fdb_protocol_1 = require("@fitbit/fdb-protocol");
var lodash = require("lodash");
var JSZip = require("jszip");
var package_json_1 = require("../package.json");
var BulkDataReceiver_1 = require("./BulkDataReceiver");
var ConfigurableEncode_1 = require("./ConfigurableEncode");
var componentBundle_1 = require("./componentBundle");
var FBOS3_EVAL_QUIRK = /^[a-zA-Z]+ \d+\.33\.1\.\d+$/;
var RemoteHost = (function (_super) {
    tslib_1.__extends(RemoteHost, _super);
    function RemoteHost(timeout) {
        var _this = _super.call(this) || this;
        _this.dispatcher = new jsonrpc_ts_1.TypesafeRequestDispatcher();
        _this.rpc = new jsonrpc_ts_1.Peer(_this.dispatcher);
        _this.bulkDataStreams = new fdb_protocol_1.BulkData();
        _this.screenshotReceiver = new BulkDataReceiver_1.default(_this.bulkDataStreams, 'screenshot');
        _this.appContentsListReceiver = new BulkDataReceiver_1.default(_this.bulkDataStreams, 'app component contents list');
        _this.heapSnapshotReceiver = new BulkDataReceiver_1.default(_this.bulkDataStreams, 'heap snapshot');
        _this.serializerTransform = new ConfigurableEncode_1.default();
        _this.handleMessage = function (params) {
            if (params.timestamp) {
                _this.emit('consoleMessage', tslib_1.__assign({}, params, { timestamp: _this.convertTimestamp(params.timestamp) }));
            }
            else {
                _this.emit('consoleMessage', params);
            }
        };
        _this.handleTrace = function (params) {
            if (params.timestamp) {
                _this.emit('consoleTrace', tslib_1.__assign({}, params, { timestamp: _this.convertTimestamp(params.timestamp) }));
            }
            else {
                _this.emit('consoleTrace', params);
            }
        };
        _this.handleAppRunning = function (params) {
            _this.emit('appRunning', params);
        };
        _this.handleAppClosed = function (params) {
            _this.emit('appClosed', params);
        };
        _this.initialize = _this.bindMethod('initialize', fdb_protocol_1.FDBTypes.InitializeParams, fdb_protocol_1.FDBTypes.InitializeResult);
        _this.ping = function () { return _this.rpc.callMethod('ping', undefined, { timeout: _this.timeout }); };
        _this.ioWrite = _this.bindMethod('io.write', fdb_protocol_1.FDBTypes.IOWriteParams, t.any, { timeoutEnabled: false });
        _this.beginStreamingInstall = _this.bindMethod('app.install.stream.begin', fdb_protocol_1.FDBTypes.AppInstallStreamBeginParams, fdb_protocol_1.FDBTypes.StreamOpenResponse);
        _this.finalizeStreamingInstall = _this.bindMethod('app.install.stream.finalize', fdb_protocol_1.FDBTypes.StreamCloseParams, fdb_protocol_1.FDBTypes.AppInstallResult, { minTimeout: 300000 });
        _this.abortStreamingInstall = _this.bindMethod('app.install.stream.abort', fdb_protocol_1.FDBTypes.StreamCloseParams, t.any);
        _this.launchAppComponent = _this.bindMethod('app.launchComponent', fdb_protocol_1.FDBTypes.LaunchComponentParams, fdb_protocol_1.FDBTypes.AppComponent);
        _this.changeSerialization = function (serialization) {
            _this.rpc.sendNotification('protocol.serialization.change', { serialization: serialization });
            _this.serializerTransform.setEncoder(serialization);
        };
        _this.beginStreamingScreenshotCapture = _this.bindMethod('app.screenshot.stream.capture', fdb_protocol_1.FDBTypes.AppScreenshotStreamCaptureParams, fdb_protocol_1.FDBTypes.AppScreenshotStreamCaptureResult);
        _this.sendEvalCmd = _this.bindMethod('app.debug.evalToString', fdb_protocol_1.FDBTypes.AppDebugEvalParams, fdb_protocol_1.FDBTypes.AppDebugEvalResult);
        _this.beginStreamingAppComponentContents = _this.bindMethod('app.contents.stream.list', fdb_protocol_1.FDBTypes.AppComponentContentsRequest, t.any);
        _this.beginHeapSnapshotCapture = _this.bindMethod('app.debug.heapSnapshot.capture', fdb_protocol_1.FDBTypes.AppHeapSnapshotRequest, t.any);
        _this.timeout = timeout;
        _this.dispatcher
            .method('ping', t.undefined, function () { })
            .notification('console.message', fdb_protocol_1.FDBTypes.ConsoleMessage, _this.handleMessage)
            .notification('console.traceMessage', fdb_protocol_1.FDBTypes.TraceMessage, _this.handleTrace)
            .notification('experimental.lifecycle.appRunning', fdb_protocol_1.FDBTypes.App, _this.handleAppRunning)
            .notification('experimental.lifecycle.appClosed', fdb_protocol_1.FDBTypes.App, _this.handleAppClosed);
        _this.bulkDataStreams.register(_this.dispatcher);
        _this.screenshotReceiver.registerCloserMethods(_this.dispatcher, 'app.screenshot.stream');
        _this.appContentsListReceiver.registerCloserMethods(_this.dispatcher, 'app.contents.stream');
        _this.heapSnapshotReceiver.registerCloserMethods(_this.dispatcher, 'app.debug.heapSnapshot');
        return _this;
    }
    RemoteHost.connect = function (hostStream, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.userAgentSuffix, userAgentSuffix = _c === void 0 ? '' : _c, _d = _b.timeout, timeout = _d === void 0 ? 10000 : _d;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userAgent, host, reqTime, _e;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        userAgent = this.USER_AGENT;
                        if (userAgentSuffix) {
                            userAgent = userAgent + " " + userAgentSuffix;
                        }
                        host = new this(timeout);
                        hostStream
                            .pipe(new jsonrpc_ts_1.ParseJSON)
                            .pipe(host.rpc)
                            .pipe(host.serializerTransform)
                            .pipe(hostStream);
                        reqTime = Date.now();
                        _e = host;
                        return [4, host.initialize({
                                userAgent: userAgent,
                                capabilities: this.CAPABILITIES,
                            })];
                    case 1:
                        _e.info = _f.sent();
                        if (host.hasCapability('protocol.additionalSerializations') &&
                            host.info.capabilities.protocol.additionalSerializations.includes('cbor-definite')) {
                            host.changeSerialization('cbor-definite');
                        }
                        host.epoch = new Date((reqTime + Date.now()) / 2);
                        return [2, host];
                }
            });
        });
    };
    RemoteHost.prototype.convertTimestamp = function (relativeTS) {
        return new Date(this.epoch.getTime() + relativeTS * 1000);
    };
    RemoteHost.prototype.hasCapability = function (path) {
        return lodash.get(this.info.capabilities, path) !== undefined;
    };
    Object.defineProperty(RemoteHost.prototype, "maxMessageSize", {
        get: function () {
            var protocolDefaultSize = 8192;
            var capabilitySize = lodash.get(this.info.capabilities, 'protocol.maxMessageSize', 0);
            return Math.max(protocolDefaultSize, capabilitySize);
        },
        enumerable: true,
        configurable: true
    });
    RemoteHost.prototype.bindMethod = function (method, paramsType, resultType, _a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.timeoutEnabled, timeoutEnabled = _c === void 0 ? true : _c, _d = _b.minTimeout, minTimeout = _d === void 0 ? 0 : _d;
        return function (params) {
            return _this.rpc.callMethod(method, params, {
                timeout: timeoutEnabled ? Math.max(_this.timeout, minTimeout) : undefined,
            }).then(jsonrpc_ts_1.decode(resultType));
        };
    };
    RemoteHost.prototype.writeToStream = function (stream, data, _a) {
        var _b = (_a === void 0 ? {} : _a).onProgress, onProgress = _b === void 0 ? (function () { }) : _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var overheadChars, maxDataBytes, expireWriteTimeout, writeTimedOut, timeoutTimer, resetWriteTimeout, writes, _loop_1, this_1, cursor;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        overheadChars = 256;
                        maxDataBytes = fdb_protocol_1.maxBase64DecodedSize(this.maxMessageSize - overheadChars);
                        if (maxDataBytes < 1) {
                            throw new Error('Cannot fit any data into an io.write message');
                        }
                        writeTimedOut = new Promise(function (_, reject) {
                            expireWriteTimeout = function () {
                                reject(new Error('io.write timed out'));
                            };
                        });
                        timeoutTimer = setTimeout(expireWriteTimeout, this.timeout);
                        resetWriteTimeout = function () {
                            clearTimeout(timeoutTimer);
                            timeoutTimer = setTimeout(expireWriteTimeout, _this.timeout);
                        };
                        writes = [];
                        _loop_1 = function (cursor) {
                            var chunk = this_1.serializerTransform.canAcceptRawBuffers() ? {
                                stream: stream,
                                data: data.slice(cursor, cursor + maxDataBytes),
                                encoding: 'none',
                            } : {
                                stream: stream,
                                data: data.toString('base64', cursor, cursor + maxDataBytes),
                            };
                            writes.push(this_1.ioWrite(chunk).then(function () {
                                resetWriteTimeout();
                                onProgress(Math.min(cursor + maxDataBytes, data.length), data.length);
                            }));
                        };
                        this_1 = this;
                        for (cursor = 0; cursor < data.length; cursor += maxDataBytes) {
                            _loop_1(cursor);
                        }
                        return [4, Promise.race([Promise.all(writes), writeTimedOut])];
                    case 1:
                        _c.sent();
                        clearTimeout(timeoutTimer);
                        return [2];
                }
            });
        });
    };
    RemoteHost.prototype.installApp = function (componentBundle, data, _a) {
        var _b = (_a === void 0 ? {} : _a).onProgress, onProgress = _b === void 0 ? (function () { }) : _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var bundleData, bundleZip, uuid, existingContents, partialBundle, _c, stream, e_1;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        bundleData = data;
                        if (!this.supportsPartialAppInstall()) return [3, 7];
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, , 7]);
                        return [4, JSZip.loadAsync(data)];
                    case 2:
                        bundleZip = _d.sent();
                        return [4, componentBundle_1.getAppUUID(bundleZip)];
                    case 3:
                        uuid = _d.sent();
                        return [4, this.getInstalledAppContents(uuid, componentBundle)];
                    case 4:
                        existingContents = _d.sent();
                        return [4, componentBundle_1.makePartialBundle(bundleZip, existingContents)];
                    case 5:
                        partialBundle = _d.sent();
                        if (partialBundle == null) {
                            return [2, null];
                        }
                        bundleData = partialBundle;
                        return [3, 7];
                    case 6:
                        _c = _d.sent();
                        return [3, 7];
                    case 7: return [4, this.beginStreamingInstall({ componentBundle: componentBundle })];
                    case 8:
                        stream = (_d.sent()).stream;
                        _d.label = 9;
                    case 9:
                        _d.trys.push([9, 11, , 12]);
                        return [4, this.writeToStream(stream, bundleData, { onProgress: onProgress })];
                    case 10:
                        _d.sent();
                        return [3, 12];
                    case 11:
                        e_1 = _d.sent();
                        this.abortStreamingInstall({ stream: stream });
                        throw e_1;
                    case 12: return [2, this.finalizeStreamingInstall({ stream: stream })
                            .then(function (result) { return (tslib_1.__assign({ installType: 'full' }, result)); })];
                }
            });
        });
    };
    RemoteHost.prototype.canTakeScreenshot = function () {
        return (this.hasCapability('appHost.screenshot') &&
            !!this.info.capabilities.appHost.screenshot.stream);
    };
    RemoteHost.prototype.screenshotFormats = function () {
        if (!this.canTakeScreenshot())
            return [];
        return this.info.capabilities.appHost.screenshot.imageFormats;
    };
    RemoteHost.prototype.takeScreenshot = function (format, onWrite) {
        var _this = this;
        return this.screenshotReceiver.receiveFromStream(function (stream) {
            return _this.beginStreamingScreenshotCapture({ stream: stream.token, imageFormat: format })
                .then(function (_a) {
                var length = _a.length;
                if (onWrite) {
                    stream.onWrite = function (_, received) { return onWrite(received, length); };
                }
            });
        });
    };
    RemoteHost.prototype.hasEvalSupport = function () {
        return this.hasCapability('appHost.debug.app.evalToString.supported') &&
            this.info.capabilities.appHost.debug.app.evalToString.supported &&
            !FBOS3_EVAL_QUIRK.test(this.info.device);
    };
    RemoteHost.prototype.eval = function (cmd) {
        return this.sendEvalCmd({ cmd: cmd });
    };
    RemoteHost.prototype.supportsPartialAppInstall = function () {
        return this.hasCapability('appHost.install.partialBundle') &&
            this.info.capabilities.appHost.install.partialBundle;
    };
    RemoteHost.prototype.getInstalledAppContents = function (uuid, componentBundle) {
        var _this = this;
        return this.appContentsListReceiver.receiveFromStream(function (stream) { return _this.beginStreamingAppComponentContents({
            componentBundle: componentBundle,
            uuid: uuid,
            stream: stream.token,
        }); })
            .then(function (buffer) { return JSON.parse(buffer.toString()); })
            .then(jsonrpc_ts_1.decode(fdb_protocol_1.FDBTypes.AppComponentContentsList));
    };
    RemoteHost.prototype.getHeapSnapshotSupport = function () {
        return tslib_1.__assign({ supported: false, requiresInstrumentedLaunch: false, formats: [] }, (this.hasCapability('appHost.debug.app.heapSnapshot') &&
            this.info.capabilities.appHost.debug.app.heapSnapshot));
    };
    RemoteHost.prototype.captureHeapSnapshot = function (format) {
        var _this = this;
        return this.heapSnapshotReceiver.receiveFromStream(function (stream) { return _this.beginHeapSnapshotCapture({ format: format, stream: stream.token }); });
    };
    RemoteHost.CAPABILITIES = {
        protocol: { maxMessageSize: 1024 * 1024 },
        console: { appLogging: true },
        io: { write: true },
    };
    RemoteHost.USER_AGENT = "fdb-debugger/" + package_json_1.version;
    return RemoteHost;
}(events_1.EventEmitter));
exports.RemoteHost = RemoteHost;
//# sourceMappingURL=index.js.map