"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var simpleSHA256 = require("simple-sha256");
function getAppUUID(zipFile) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile, manifest, _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    manifestFile = zipFile.file('manifest.json');
                    if (manifestFile == null) {
                        throw new Error('Not a valid component bundle: manifest.json not present');
                    }
                    _b = (_a = JSON).parse;
                    return [4, manifestFile.async('text')];
                case 1:
                    manifest = _b.apply(_a, [_c.sent()]);
                    if (typeof manifest.uuid !== 'string') {
                        throw new Error('Not a valid component bundle: "uuid" field in manifest.json is missing or not a string');
                    }
                    return [2, manifest.uuid];
            }
        });
    });
}
exports.getAppUUID = getAppUUID;
function makePartialBundle(zipFile, existing) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var deleteList, manifestIsIdentical, filesArePruned, _i, _a, _b, path, sha256, file, zipdigest, partialManifest;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (zipFile.file('.partial.json')) {
                        throw new Error('Component bundle already contains .partial.json');
                    }
                    deleteList = [];
                    manifestIsIdentical = false;
                    filesArePruned = false;
                    _i = 0, _a = Object.entries(existing.files);
                    _c.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3, 5];
                    _b = _a[_i], path = _b[0], sha256 = _b[1].sha256;
                    file = zipFile.file(path);
                    if (!(file == null)) return [3, 2];
                    deleteList.push(path);
                    return [3, 4];
                case 2: return [4, file.async('uint8array').then(simpleSHA256)];
                case 3:
                    zipdigest = _c.sent();
                    if (sha256.toLowerCase() === zipdigest.toLowerCase()) {
                        if (path === 'manifest.json') {
                            manifestIsIdentical = true;
                        }
                        else {
                            zipFile.remove(path);
                            filesArePruned = true;
                        }
                    }
                    _c.label = 4;
                case 4:
                    _i++;
                    return [3, 1];
                case 5:
                    if (manifestIsIdentical &&
                        deleteList.length === 0 &&
                        zipFile.filter(function (path, file) { return path !== 'manifest.json' && !file.dir; }).length === 0) {
                        return [2, null];
                    }
                    if (!filesArePruned) {
                        throw new Error('No files can be reused for partial app install');
                    }
                    partialManifest = {
                        delete: deleteList,
                    };
                    zipFile.file('.partial.json', JSON.stringify(partialManifest));
                    return [2, zipFile.generateAsync({
                            type: 'nodebuffer',
                            compression: 'DEFLATE',
                        })];
            }
        });
    });
}
exports.makePartialBundle = makePartialBundle;
//# sourceMappingURL=componentBundle.js.map