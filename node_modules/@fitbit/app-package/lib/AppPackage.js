"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var apr_map_1 = require("apr-map");
var lodash = require("lodash");
function getFile(zip, path) {
    var file = zip.file(path);
    if (!file || file.dir)
        throw new Error(path + " not present in zip file");
    return file;
}
function getBufferFromZip(zip, path) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2, getFile(zip, path).async('nodebuffer')];
        });
    });
}
function getTextFromZip(zip, path) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2, getFile(zip, path).async('text')];
        });
    });
}
var extractComponentSourceMaps = function (sourceMapPaths, zip) {
    return apr_map_1.default(sourceMapPaths, function (path) { return getTextFromZip(zip, path).then(JSON.parse); });
};
function extractSourceMaps(zip, sourceMapManifest) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var extractComponent, _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!sourceMapManifest)
                        return [2, undefined];
                    extractComponent = function (component) {
                        return component ? extractComponentSourceMaps(component, zip) : undefined;
                    };
                    _a = {};
                    if (!sourceMapManifest.device) return [3, 2];
                    return [4, apr_map_1.default(sourceMapManifest.device, function (component) { return extractComponentSourceMaps(component, zip); })];
                case 1:
                    _b = _c.sent();
                    return [3, 3];
                case 2:
                    _b = undefined;
                    _c.label = 3;
                case 3:
                    _a.device = _b;
                    return [4, extractComponent(sourceMapManifest.companion)];
                case 4:
                    _a.companion = _c.sent();
                    return [4, extractComponent(sourceMapManifest.settings)];
                case 5: return [2, (_a.settings = _c.sent(),
                        _a)];
            }
        });
    });
}
var ManifestParserBase = (function () {
    function ManifestParserBase() {
    }
    ManifestParserBase.prototype.pullMetadata = function () {
        return {
            buildId: this.manifest.buildId,
            uuid: this.manifest.appId,
            requestedPermissions: this.manifest.requestedPermissions,
        };
    };
    ManifestParserBase.prototype.getSDKVersions = function () {
        var versions = {
            deviceApi: '1.0.0',
        };
        if (this.manifest.components.companion)
            versions.companionApi = '1.0.0';
        return versions;
    };
    return ManifestParserBase;
}());
var ManifestParserV5 = (function (_super) {
    tslib_1.__extends(ManifestParserV5, _super);
    function ManifestParserV5(manifest) {
        var _this = _super.call(this) || this;
        _this.manifest = manifest;
        return _this;
    }
    ManifestParserV5.prototype.getDeviceComponents = function () {
        var _this = this;
        if (typeof this.manifest.components !== 'object' || !this.manifest.components.watch) {
            throw new Error('No components listed in manifest.json');
        }
        if (!Array.isArray(this.manifest.platform)) {
            throw new Error('Missing platform descriptors');
        }
        return this.manifest.platform.map(function (platformDescriptor) {
            var _a = /^([^:]+):?(.+)?$/.exec(platformDescriptor), family = _a[1], platform = _a[2];
            return [
                family.toLowerCase(),
                {
                    platform: platform ? [platform] : undefined,
                    filename: _this.manifest.components.watch,
                },
            ];
        });
    };
    ManifestParserV5.prototype.getCompanionFilename = function () {
        return this.manifest.components.companion;
    };
    ManifestParserV5.prototype.getSourceMapExtractor = function () {
        return function () { return Promise.resolve(undefined); };
    };
    return ManifestParserV5;
}(ManifestParserBase));
var ManifestParserV6 = (function (_super) {
    tslib_1.__extends(ManifestParserV6, _super);
    function ManifestParserV6(manifest) {
        var _this = _super.call(this) || this;
        _this.manifest = manifest;
        return _this;
    }
    ManifestParserV6.prototype.getDeviceComponents = function () {
        if (typeof this.manifest.components !== 'object') {
            throw new Error('No components listed in manifest.json');
        }
        if (!this.manifest.components.watch)
            return [];
        return Object.entries(this.manifest.components.watch);
    };
    ManifestParserV6.prototype.getCompanionFilename = function () {
        return lodash.get(this.manifest, 'components.companion.filename');
    };
    ManifestParserV6.prototype.getSDKVersions = function () {
        return tslib_1.__assign({}, _super.prototype.getSDKVersions.call(this), this.manifest.sdkVersion);
    };
    ManifestParserV6.prototype.getSourceMapExtractor = function () {
        var _this = this;
        return function (zip) { return extractSourceMaps(zip, _this.manifest.sourceMaps); };
    };
    return ManifestParserV6;
}(ManifestParserBase));
function getManifestParser(manifest) {
    switch (manifest.manifestVersion) {
        case 5:
            return new ManifestParserV5(manifest);
        case 6:
            return new ManifestParserV6(manifest);
        default:
            throw new Error("Unsupported manifest version " + manifest.manifestVersion);
    }
}
function fromJSZip(fbaZip) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var textFile, bufferFile, manifestJSON, _a, _b, parser, device, companionFilename, companion, _c, sourceMaps;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    textFile = function (path) { return getTextFromZip(fbaZip, path); };
                    bufferFile = function (path) { return getBufferFromZip(fbaZip, path); };
                    _b = (_a = JSON).parse;
                    return [4, textFile('manifest.json')];
                case 1:
                    manifestJSON = _b.apply(_a, [_d.sent()]);
                    parser = getManifestParser(manifestJSON);
                    return [4, Promise.all(parser.getDeviceComponents().map(function (_a) {
                            var family = _a[0], _b = _a[1], platform = _b.platform, filename = _b.filename;
                            return bufferFile(filename)
                                .then(function (artifact) { return [family, { platform: platform, artifact: artifact }]; });
                        })).then(lodash.fromPairs)];
                case 2:
                    device = _d.sent();
                    companionFilename = parser.getCompanionFilename();
                    if (!companionFilename) return [3, 4];
                    return [4, bufferFile(companionFilename)];
                case 3:
                    _c = _d.sent();
                    return [3, 5];
                case 4:
                    _c = undefined;
                    _d.label = 5;
                case 5:
                    companion = _c;
                    return [4, parser.getSourceMapExtractor()(fbaZip)];
                case 6:
                    sourceMaps = _d.sent();
                    return [2, tslib_1.__assign({}, parser.pullMetadata(), { sourceMaps: sourceMaps, components: {
                                device: device,
                                companion: companion,
                            }, sdkVersion: parser.getSDKVersions() })];
            }
        });
    });
}
exports.fromJSZip = fromJSZip;
//# sourceMappingURL=AppPackage.js.map