"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var events_1 = require("events");
var t = require("io-ts");
var jsonrpc_ts_1 = require("@fitbit/jsonrpc-ts");
var fdb_protocol_1 = require("@fitbit/fdb-protocol");
var Host = (function (_super) {
    tslib_1.__extends(Host, _super);
    function Host(hostInfo, timeout) {
        var _this = _super.call(this) || this;
        _this.dispatcher = new jsonrpc_ts_1.TypesafeRequestDispatcher();
        _this.rpc = new jsonrpc_ts_1.Peer(_this.dispatcher);
        _this.bulkDataStreams = new fdb_protocol_1.BulkData();
        _this.setInstallHandler = function (installHandler, installOptions) {
            _this.installHandler = installHandler;
            _this.capabilities.io = {
                write: true,
            };
            _this.capabilities.appHost = {
                install: tslib_1.__assign({}, installOptions, { sideloadStream: true }),
            };
        };
        _this.handleInitialize = function (params) {
            _this.info = params;
            _this.epoch = new Date();
            _this.emit('initialized');
            return {
                device: _this.hostInfo.device,
                hostKind: _this.hostInfo.hostKind,
                capabilities: _this.capabilities,
            };
        };
        _this.handleAppInstallBegin = function (params) {
            var stream = _this.bulkDataStreams.createWriteStream();
            if (_this.appInstallStream != null) {
                throw new jsonrpc_ts_1.InvalidParams('App install stream is currently being used');
            }
            _this.appInstallStream = stream;
            return {
                stream: stream.token,
            };
        };
        _this.handleAppInstallFinalize = function (_a) {
            var stream = _a.stream;
            return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var finalizedBuffer;
                return tslib_1.__generator(this, function (_b) {
                    this.validateAppInstallStream(stream);
                    if (!this.installHandler) {
                        throw new jsonrpc_ts_1.InvalidParams('No install handler has been set');
                    }
                    finalizedBuffer = this.appInstallStream.finalize();
                    this.appInstallStream = undefined;
                    return [2, this.installHandler(finalizedBuffer)];
                });
            });
        };
        _this.handleAppInstallAbort = function (_a) {
            var stream = _a.stream;
            _this.validateAppInstallStream(stream);
            _this.appInstallStream.finalize();
            _this.appInstallStream = undefined;
        };
        _this.ping = function (timeout) {
            if (timeout === void 0) { timeout = 10000; }
            return _this.rpc.callMethod('ping', undefined, { timeout: timeout });
        };
        _this.consoleMessage = function (args) {
            return _this.rpc.sendNotification('console.message', args);
        };
        _this.consoleTrace = function (args) {
            return _this.rpc.sendNotification('console.traceMessage', args);
        };
        _this.hostInfo = hostInfo;
        _this.timeout = timeout;
        _this.capabilities = {
            protocol: {
                maxMessageSize: _this.hostInfo.maxMessageSize,
            },
        };
        _this.dispatcher
            .method('ping', t.undefined, function () { })
            .method('initialize', fdb_protocol_1.FDBTypes.InitializeParams, _this.handleInitialize)
            .method('app.install.stream.begin', fdb_protocol_1.FDBTypes.AppInstallStreamBeginParams, _this.handleAppInstallBegin)
            .method('app.install.stream.finalize', fdb_protocol_1.FDBTypes.StreamCloseParams, _this.handleAppInstallFinalize)
            .method('app.install.stream.abort', fdb_protocol_1.FDBTypes.StreamCloseParams, _this.handleAppInstallAbort);
        _this.bulkDataStreams.register(_this.dispatcher);
        return _this;
    }
    Host.create = function (debuggerStream, hostInfo, _a) {
        var _b = (_a === void 0 ? {} : _a).timeout, timeout = _b === void 0 ? 10000 : _b;
        var host = new this(hostInfo, timeout);
        debuggerStream
            .pipe(new jsonrpc_ts_1.ParseJSON)
            .pipe(host.rpc)
            .pipe(new jsonrpc_ts_1.StringifyJSON)
            .pipe(debuggerStream);
        return host;
    };
    Host.prototype.validateAppInstallStream = function (stream) {
        if (!this.appInstallStream) {
            throw new jsonrpc_ts_1.InvalidParams('No current app install stream exists');
        }
        if (stream !== this.appInstallStream.token) {
            throw new jsonrpc_ts_1.InvalidParams('Stream token does not match the current app install stream', { stream: stream });
        }
    };
    return Host;
}(events_1.EventEmitter));
exports.Host = Host;
//# sourceMappingURL=index.js.map