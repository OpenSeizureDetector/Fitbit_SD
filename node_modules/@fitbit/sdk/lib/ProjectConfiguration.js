"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const humanize_list_1 = tslib_1.__importDefault(require("humanize-list"));
const validator_1 = require("validator");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const buildTargets_1 = tslib_1.__importDefault(require("./buildTargets"));
const DiagnosticList_1 = tslib_1.__importDefault(require("./DiagnosticList"));
const languageTag_1 = require("./languageTag");
const sdkVersion_1 = tslib_1.__importDefault(require("./sdkVersion"));
const knownBuildTargets = Object.keys(buildTargets_1.default);
var AppType;
(function (AppType) {
    AppType["APP"] = "app";
    AppType["CLOCKFACE"] = "clockface";
})(AppType = exports.AppType || (exports.AppType = {}));
exports.VALID_APP_TYPES = Object.values(AppType);
exports.MAX_DISPLAY_NAME_LENGTH = 30;
exports.LOCALES = Object.freeze({
    en: 'English',
    de: 'German',
    es: 'Spanish',
    fr: 'French',
    it: 'Italian',
    ja: 'Japanese',
    ko: 'Korean',
    nl: 'Dutch',
    sv: 'Swedish',
    'zh-cn': 'Chinese (S)',
    'zh-tw': 'Chinese (T)',
});
const permissionTypes = [
    {
        key: 'access_activity',
        name: 'Activity',
        description: 'Read user activities for today (distance, calories, steps, elevation and active minutes), and daily goals.',
    },
    {
        key: 'access_user_profile',
        name: 'User Profile',
        description: 'Read non-identifiable personal information (gender, age, height, weight, resting HR, basal metabolic rate, stride, HR zones).',
    },
    {
        key: 'access_heart_rate',
        name: 'Heart Rate',
        description: 'Application may read the heart-rate sensor in real-time.',
    },
    {
        key: 'access_location',
        name: 'Location',
        description: 'Application and companion may use GPS.',
    },
    {
        key: 'access_internet',
        name: 'Internet',
        description: 'Companion may communicate with the Internet using your phone data connection.',
    },
    {
        key: 'run_background',
        name: 'Run in background',
        description: 'Companion may run even when the application is not actively in use.',
    },
    {
        key: 'access_exercise',
        name: 'Exercise Tracking',
        description: 'Application may track an exercise.',
        sdkVersion: '>=3.0.0',
    },
];
const restrictedPermissionTypes = [
    {
        key: 'fitbit_token',
        name: '[Restricted] Fitbit Token',
        description: 'Access Fitbit API token.',
    },
    {
        key: 'external_app_communication',
        name: '[Restricted] External Application Communication',
        description: 'Allows communication between external mobile applications and companion.',
    },
    {
        key: 'access_secure_exchange',
        name: '[Restricted] Secure Exchange',
        description: 'Allows securing any data and verifying that data was secured',
    },
];
function getAllPermissionTypes() {
    return [
        ...restrictedPermissionTypes,
        ...permissionTypes.filter((permission) => !permission.sdkVersion ||
            semver_1.default.satisfies(sdkVersion_1.default(), permission.sdkVersion)),
    ];
}
function constrainedSetDiagnostics({ actualValues, knownValues, valueTypeNoun, notFoundIsFatal = false, }) {
    const unknownValues = lodash_1.default.without(actualValues, ...knownValues);
    const diagnostics = new DiagnosticList_1.default();
    if (unknownValues.length > 0) {
        const unknownValueStrings = unknownValues.filter(lodash_1.default.isString);
        const unknownValueOther = lodash_1.default
            .without(unknownValues, ...unknownValueStrings)
            .map(String);
        if (unknownValueStrings.length) {
            const errStr = `One or more ${valueTypeNoun} was invalid: ${unknownValueStrings.join(', ')}`;
            if (notFoundIsFatal)
                diagnostics.pushFatalError(errStr);
            else
                diagnostics.pushWarning(errStr);
        }
        if (unknownValueOther.length) {
            diagnostics.pushFatalError(`One or more ${valueTypeNoun} was not a string: ${unknownValueOther.join(', ')}`);
        }
    }
    const duplicatedValues = lodash_1.default
        .uniq(actualValues)
        .filter((value) => actualValues.indexOf(value) !== actualValues.lastIndexOf(value));
    if (duplicatedValues.length > 0) {
        diagnostics.pushWarning(`One or more ${valueTypeNoun} was specified multiple times: ${duplicatedValues.join(', ')}`);
    }
    return diagnostics;
}
function normalizeProjectConfig(config, defaults) {
    if (!lodash_1.default.isPlainObject(config)) {
        throw new TypeError('Project configuration root must be an object');
    }
    const mergedConfig = Object.assign({ appUUID: '', appType: AppType.APP, appDisplayName: '', iconFile: 'resources/icon.png', wipeColor: '', requestedPermissions: [], buildTargets: [], i18n: {}, defaultLanguage: 'en-US' }, defaults, config.fitbit);
    const normalizedDefaultLanguage = languageTag_1.normalizeLanguageTag(mergedConfig.defaultLanguage);
    if (normalizedDefaultLanguage !== null) {
        mergedConfig.defaultLanguage = normalizedDefaultLanguage;
    }
    const { requestedPermissions } = mergedConfig;
    if (!Array.isArray(requestedPermissions)) {
        throw new TypeError(`fitbit.requestedPermissions must be an array, not ${typeof requestedPermissions}`);
    }
    return mergedConfig;
}
exports.normalizeProjectConfig = normalizeProjectConfig;
function validateAppType(config) {
    const diagnostics = new DiagnosticList_1.default();
    if (exports.VALID_APP_TYPES.indexOf(config.appType) === -1) {
        const appTypeNames = humanize_list_1.default(exports.VALID_APP_TYPES, { conjunction: 'or' });
        diagnostics.pushFatalError(`App type '${config.appType}' is invalid, expected ${appTypeNames}`);
    }
    return diagnostics;
}
exports.validateAppType = validateAppType;
function validateDisplayName(name) {
    if (name.length === 0) {
        return 'Display name must not be blank';
    }
    if (name.length > exports.MAX_DISPLAY_NAME_LENGTH) {
        return `Display name must not exceed ${exports.MAX_DISPLAY_NAME_LENGTH} characters`;
    }
    return true;
}
exports.validateDisplayName = validateDisplayName;
function validateProjectDisplayName(config) {
    const diagnostics = new DiagnosticList_1.default();
    const result = validateDisplayName(config.appDisplayName);
    if (result !== true) {
        diagnostics.pushFatalError(result);
    }
    return diagnostics;
}
exports.validateProjectDisplayName = validateProjectDisplayName;
function validateWipeColor(config) {
    const diagnostics = new DiagnosticList_1.default();
    if (config.appType !== AppType.CLOCKFACE && !validator_1.isHexColor(config.wipeColor)) {
        diagnostics.pushFatalError('Wipe color must be a valid hex color');
    }
    return diagnostics;
}
exports.validateWipeColor = validateWipeColor;
function validateRequestedPermissions({ requestedPermissions, }) {
    return constrainedSetDiagnostics({
        actualValues: requestedPermissions,
        knownValues: getAllPermissionTypes().map((permission) => permission.key),
        valueTypeNoun: 'requested permissions',
        notFoundIsFatal: false,
    });
}
exports.validateRequestedPermissions = validateRequestedPermissions;
function validateBuildTarget({ buildTargets }) {
    const diagnostics = constrainedSetDiagnostics({
        actualValues: buildTargets,
        knownValues: knownBuildTargets,
        valueTypeNoun: 'build targets',
        notFoundIsFatal: true,
    });
    if (buildTargets.length === 0) {
        diagnostics.pushFatalError('At least one build target must be enabled');
    }
    return diagnostics;
}
exports.validateBuildTarget = validateBuildTarget;
function validateLocaleDisplayName({ i18n }, localeKey) {
    const diagnostics = new DiagnosticList_1.default();
    const locale = i18n[localeKey];
    if (!locale)
        return diagnostics;
    if (!locale.name || locale.name.length === 0) {
        diagnostics.pushFatalError(`Localized display name for ${exports.LOCALES[localeKey]} must not be blank`);
    }
    if (locale.name.length > exports.MAX_DISPLAY_NAME_LENGTH) {
        diagnostics.pushFatalError(`Localized display name for ${exports.LOCALES[localeKey]} must not exceed ${exports.MAX_DISPLAY_NAME_LENGTH} characters`);
    }
    return diagnostics;
}
exports.validateLocaleDisplayName = validateLocaleDisplayName;
function validateLocaleDisplayNames(config) {
    const diagnostics = new DiagnosticList_1.default();
    for (const localeKey of Object.keys(exports.LOCALES)) {
        diagnostics.extend(validateLocaleDisplayName(config, localeKey));
    }
    return diagnostics;
}
exports.validateLocaleDisplayNames = validateLocaleDisplayNames;
function validateSupportedLocales({ i18n }) {
    const diagnostics = new DiagnosticList_1.default();
    const unknownLocales = lodash_1.default.without(Object.keys(i18n), ...Object.keys(exports.LOCALES));
    if (unknownLocales.length > 0) {
        diagnostics.pushWarning(`Invalid locales: ${unknownLocales.join(', ')}`);
    }
    return diagnostics;
}
exports.validateSupportedLocales = validateSupportedLocales;
function validateAppUUID({ appUUID }) {
    const diagnostics = new DiagnosticList_1.default();
    if (!validator_1.isUUID(String(appUUID))) {
        diagnostics.pushFatalError('appUUID must be a valid UUID, run "npx fitbit-build generate-appid" to fix');
    }
    return diagnostics;
}
exports.validateAppUUID = validateAppUUID;
function validateDefaultLanguage(config) {
    const diagnostics = new DiagnosticList_1.default();
    if (languageTag_1.normalizeLanguageTag(config.defaultLanguage) === null) {
        diagnostics.pushFatalError(`Default language is an invalid language tag: ${config.defaultLanguage}`);
    }
    return diagnostics;
}
exports.validateDefaultLanguage = validateDefaultLanguage;
function validate(config) {
    const diagnostics = new DiagnosticList_1.default();
    [
        validateAppUUID,
        validateProjectDisplayName,
        validateAppType,
        validateWipeColor,
        validateRequestedPermissions,
        validateBuildTarget,
        validateSupportedLocales,
        validateLocaleDisplayNames,
        validateDefaultLanguage,
    ].forEach((validator) => diagnostics.extend(validator(config)));
    return diagnostics;
}
exports.validate = validate;
