/// <reference types="node" />
import * as t from 'io-ts';
export declare const IOCapabilities: t.PartialType<{
    write: t.BooleanType;
    additionalEncodings: t.ArrayType<t.StringType, string[], string[], unknown>;
}, t.TypeOfPartialProps<{
    write: t.BooleanType;
    additionalEncodings: t.ArrayType<t.StringType, string[], string[], unknown>;
}>, t.OutputOfPartialProps<{
    write: t.BooleanType;
    additionalEncodings: t.ArrayType<t.StringType, string[], string[], unknown>;
}>, unknown>;
export declare type IOCapabilities = t.TypeOf<typeof IOCapabilities>;
export declare const StreamToken: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
export declare type StreamToken = t.TypeOf<typeof StreamToken>;
export declare const StreamOpenResponse: t.InterfaceType<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}, t.TypeOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}>, t.OutputOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}>, unknown>;
export declare type StreamOpenResponse = t.TypeOf<typeof StreamOpenResponse>;
export declare const StreamCloseParams: t.InterfaceType<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}, t.TypeOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}>, t.OutputOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
}>, unknown>;
export declare type StreamCloseParams = t.TypeOf<typeof StreamCloseParams>;
export declare const IOEncoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
export declare type IOEncoding = t.TypeOf<typeof IOEncoding>;
export declare class NodeBufferType extends t.Type<Buffer> {
    readonly _tag: 'NodeBufferType';
    constructor();
}
export declare const NodeBuffer: NodeBufferType;
export declare const IOWriteParams: t.IntersectionType<[t.InterfaceType<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
    data: t.UnionType<(t.StringType | NodeBufferType)[], string | Buffer, string | Buffer, unknown>;
}, t.TypeOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
    data: t.UnionType<(t.StringType | NodeBufferType)[], string | Buffer, string | Buffer, unknown>;
}>, t.OutputOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
    data: t.UnionType<(t.StringType | NodeBufferType)[], string | Buffer, string | Buffer, unknown>;
}>, unknown>, t.PartialType<{
    encoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
}, t.TypeOfPartialProps<{
    encoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
}>, t.OutputOfPartialProps<{
    encoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
}>, unknown>], t.TypeOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
    data: t.UnionType<(t.StringType | NodeBufferType)[], string | Buffer, string | Buffer, unknown>;
}> & t.TypeOfPartialProps<{
    encoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
}>, t.OutputOfProps<{
    stream: t.UnionType<(t.StringType | t.RefinementType<t.NumberType, number, number, unknown>)[], string | number, string | number, unknown>;
    data: t.UnionType<(t.StringType | NodeBufferType)[], string | Buffer, string | Buffer, unknown>;
}> & t.OutputOfPartialProps<{
    encoding: t.UnionType<(t.LiteralType<"base64"> | t.LiteralType<"none">)[], "none" | "base64", "none" | "base64", unknown>;
}>, unknown>;
export declare type IOWriteParams = t.TypeOf<typeof IOWriteParams>;
//# sourceMappingURL=BulkData.d.ts.map